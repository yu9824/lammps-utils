import io
import os
from pathlib import Path
from typing import Literal, Optional, Union, overload

import numpy as np

from lammps_utils import __version__
from lammps_utils.io._load import _read_data_or_buffer, get_n_atoms, load_data


@overload
def data2gro(
    filepath_data_or_buffer: Union[str, os.PathLike, io.TextIOBase],
    filepath_gro: Literal[None] = None,
) -> str: ...


@overload
def data2gro(
    filepath_data_or_buffer: Union[str, os.PathLike, io.TextIOBase],
    filepath_gro: Union[str, os.PathLike],
) -> Literal[None]: ...


def data2gro(
    filepath_data_or_buffer: Union[str, os.PathLike, io.TextIOBase],
    filepath_gro: Optional[Union[str, os.PathLike]] = None,
) -> Union[str, None]:
    """
    Convert LAMMPS data file to GROMACS gro file.

    Parameters
    ----------
    filepath_data_or_buffer : Union[str, os.PathLike, io.TextIOBase]
        file path or buffer of LAMMPS data file

    filepath_gro : Optional[Union[str, os.PathLike]], optional
        file path of GROMACS gro file, by default None

    Returns
    -------
    Union[str, None]
        GROMACS gro file content if filepath_gro is None, otherwise None

    Raises
    ------
    FileNotFoundError
        If the directory of filepath_gro does not exist
    """
    if filepath_gro is not None:
        filepath_gro = Path(filepath_gro)
        if not filepath_gro.parent.is_dir():
            raise FileNotFoundError

    content_data = _read_data_or_buffer(filepath_data_or_buffer)

    df_data, cell_bounds = load_data(
        io.StringIO(content_data), return_cell_bounds=True
    )
    n_atoms = get_n_atoms(io.StringIO(content_data))

    cell_size = (
        np.array([_max - _min for _min, _max in cell_bounds]) / 10
    )  # angstrom to nm

    content_gro = (
        f"Generated by lammps-utils v{__version__}\n{n_atoms:>5}\n"
        + "\n".join(
            (
                df_data["mol"].map(lambda x: "{:>5}".format(x))
                + "MOL01"
                + df_data["symbol"].map(lambda x: "{:>5}".format(x))
                + df_data.index.map(lambda x: "{:>5}".format(x))
                + (
                    (
                        df_data[["x", "y", "z"]] / 10  # angstrom to nm
                    )
                    .map(lambda x: "{:>8.3f}".format(x))
                    .sum(axis=1)
                )
            ).tolist()
        )
        + "\n"
        + " ".join(map(lambda x: "{:.4f}".format(x), cell_size))
    )

    if filepath_gro is not None:
        with open(filepath_gro, mode="w") as f:
            f.write(content_gro)
        return None
    else:
        return content_gro


@overload
def data2pdb(
    filepath_data_or_buffer: Union[str, os.PathLike, io.TextIOBase],
    filepath_pdb: Literal[None] = None,
) -> str: ...


@overload
def data2pdb(
    filepath_data_or_buffer: Union[str, os.PathLike, io.TextIOBase],
    filepath_pdb: Union[str, os.PathLike],
) -> Literal[None]: ...


def data2pdb(
    filepath_data_or_buffer: Union[str, os.PathLike, io.TextIOBase],
    filepath_pdb: Optional[Union[str, os.PathLike]] = None,
) -> Union[str, None]:
    """
    Convert LAMMPS data file to PDB file.

    Parameters
    ----------
    filepath_data_or_buffer : Union[str, os.PathLike, io.TextIOBase]
        file path or buffer of LAMMPS data file
    filepath_pdb : Optional[Union[str, os.PathLike]], optional
        file path of PDB file, by default None

    Returns
    -------
    Union[str, None]
        PDB file content if filepath_pdb is None, otherwise None

    Raises
    ------
    FileNotFoundError
        If the directory of filepath_pdb does not exist
    """
    if filepath_pdb is not None:
        filepath_pdb = Path(filepath_pdb)
        if not filepath_pdb.parent.is_dir():
            raise FileNotFoundError

    df_atoms, df_bonds, cell_bounds = load_data(
        filepath_data_or_buffer, return_bond_info=True, return_cell_bounds=True
    )
    n_atoms = df_atoms.shape[0]
    # n_bonds = df_bonds.shape[0]

    # pdb_compnd = "COMPND  "

    pdb_author = f"AUTHOR Generated by lammps-utils v{__version__}"

    pdb_cryst1 = (
        "CRYST1"
        + "".join(
            map(lambda x: "{:>9.3f}".format(x[1] - x[0]), cell_bounds)
        )  # 格子定数
        + "  90.00" * 3  # 格子定数 (degree)
        + " P1        "  # 空間群
        + "  1"  # Z値
    )

    _list_pdb_atoms: list[str] = list()
    idx_atom_ter = n_atoms + 1
    for _idx_mol, _df_atom in (
        df_atoms.reset_index(drop=False)
        .sort_values(["mol", "id"])
        .groupby("mol")
    ):
        chain_id = chr(ord("A") + _idx_mol - 1)
        _list_pdb_atoms.append(
            "\n".join(
                "ATOM  "
                + _df_atom["id"].map(
                    lambda x: "{:>5}".format(x)
                )  # 原子の通し番号
                + " "
                + _df_atom["symbol"].map(lambda x: "{:^4}".format(x))  # 原子名
                + " "
                + "MOL"  # 残基名
                + " "
                + chain_id  # 鎖名
                # + "A"
                + "   1    "  # 残基番号
                # + "   "
                # + _df_atom["mol"].map(lambda x:"{:>4}".format(x))
                # + "    "
                + _df_atom[["x", "y", "z"]]
                .map(lambda x: "{:>8.3f}".format(x))
                .sum(axis=1)  # x,y,z座標
                + "  1.00"  # 占有率
                + "  0.00"  # 温度因子?
                + "          "
                + _df_atom["symbol"].map(
                    lambda x: "{:>2}".format(x)
                )  # 元素記号
                + "  "  # 電荷
            )
            + f"\nTER   {idx_atom_ter:>5}      MOL {chain_id}   1"
        )
        idx_atom_ter += 1
    pdb_atoms = "\n".join(_list_pdb_atoms)

    pdb_bonds = "\n".join(
        (
            "CONECT"
            + df_bonds[["atom1", "atom2"]]
            .map(lambda x: "{:>5}".format(x))
            .sum(axis=1)
            + " " * 64
        )
    )
    # pdb_master = f"MASTER        0    0    0    0    0    0    0    0{n_atoms:>5}    0{n_bonds:>5}    0"
    pdb_end = "END\n"

    content_pdb = "\n".join(
        (
            # pdb_compnd,
            pdb_author,
            pdb_cryst1,
            pdb_atoms,
            pdb_bonds,
            # pdb_master,
            pdb_end,
        )
    )

    if filepath_pdb is not None:
        with open(filepath_pdb, mode="w") as f:
            f.write(content_pdb)
        return None
    else:
        return content_pdb
